1.接口的意义
   规范， 扩展， 回调

2.抽象类的意义
   为其子类提供一个公共的类型 封装子类中的重复内容 定义抽象方法，子类虽然有不同的实现但是定义是一致的

3.抽象类和接口的区别
   定义： 抽象类使用 abstract class 关键字定义。 接口使用 interface 关键字定义
   相同点： 都可以有方法实现（Java1.8之前接口不能有方法实现） 子类不需要实现全部的方法（Java1.8之前接口的子类需要实现全部的方法）
   不同点：
          默认的方法实现 抽象类可以有默认的方法实现，这和普通类的方法实现没有区别。
               Java1.8以后接口可以使用default关键字实现默认方法而不要求其子类进行实现。
          实现 子类使用extends关键字来继承抽象类。如果子类不是抽象类的话，它需要提供抽象类中所有声明的方法的实现。
               子类使用implements关键字来实现接口。它需要提供接口中所有声明的方法的实现，
               Java1.8以后子类可以不实现接口中使用default关键字定义的默认方法。
          构造器 抽象类可以有构造器 接口不能有构造器。
                与正常Java类的区别 除了你不能实例化抽象类之外，它和普通Java类没有任何区别。 接口是完全不同的类型。
          main方法 抽象类可以有main方法并且我们可以运行它 接口没有main方法，因此我们不能运行它。
          多继承 抽象类在java语言中所表示的是一种继承关系，一个子类只能存在一个父类，但是可以存在多个接口。
          速度 抽象类比接口速度要快。 接口是稍微有点慢的，因为它需要时间去寻找在类中实现的方法。
          添加新方法 如果你往抽象类中添加新的方法，你可以给它提供默认的实现。因此你不需要改变你现在的代码。
                    如果你往接口中添加方法，那么你必须改变实现该接口的类。Java1.8以后接口可以添加default修饰的默认方法。
          成员变量 接口中定义的变量默认是public static final 型，且必须给其初值，所以实现类中不能改变其值。
                  抽象类中的变量默认是 friendly 型，其值可以在子类中重新定义，也可以重新赋值。

4.内部类的作用
   内部类可以用多个实例，每个实例都有自己的状态信息，并且与其他外围对象的信息相互独立。
   在单个外围类中，可以让多个内部类以不同的方式实现同一个接口，或者继承同一个类。
   创建内部类对象的时刻并不依赖于外围类对象的创建。
   内部类并没有令人迷惑的“is-a”关系，他就是一个独立的实体。
   内部类提供了更好的封装，除了该外围类，其他类都不能访问

5.父类的静态方法能否被子类重写
   不能， 子类继承父类后，用相同的静态方法和非静态方法，这时非静态方法覆盖父类中的方法（即方法重写），
   父类的该静态方法被隐藏（如果对象是父类则调用该隐藏的方法），另外子类可继承父类的静态与非静态方法，
   至于方法重载是在同一类中，不能说父类中的什么方法与子类里的什么方法是方法重载的体现

6.排序算法
  八大排序算法： https://www.jianshu.com/p/8c915179fd02
  查找算法： https://www.iteye.com/blog/xiaojun-it-2291852

7.jvm
  类加载机制和双亲委托模型： https://segmentfault.com/a/1190000008995781
  jvm 答疑： http://www.jackywang.tech/2017/05/11/JVM-答疑解惑/
  Dalvik： http://www.jackywang.tech/2017/08/21/关于Dalvik，我们该知道些什么？/

8.垃圾回收机制
  Java 垃圾回收机制最基本的做法是分代回收。内存中的区域被划分成不同的世代，对象根据其存活的时间被保存在对应世代的区域中。
  一般的实现是划分成3个世代：年轻、年老和永久。内存的分配是发生在年轻世代中的。当一个对象存活时间足够长的时候，它就会被复制到年老世代中。
  对于不同的世代可以使用不同的垃圾回收算法。进行世代划分的出发点是对应用中对象存活时间进行研究之后得出的统计规律。
  一般来说，一个应用中的大部分对象的存活时间都很短。比如局部变量的存活时间就只在方法的执行过程中。
  基于这一点，对于年轻世代的垃圾回收算法就可以很有针对性。

9.hashMap
  HashMap概述： HashMap是基于哈希表的Map接口的非同步实现。此实现提供所有可选的映射操作，并允许使用null值和null键。
               此类不保证映射的顺序，特别是它不保证该顺序恒久不变。
  HashMap的数据结构： 在java编程语言中，最基本的结构就是两种，一个是数组，另外一个是模拟指针（引用），
                     所有的数据结构都可以用这两个基本结构来构造的，HashMap也不例外。HashMap实际上是一个“链表散列”的数据结构，
                     即数组和链表的结合体。

10.什么导致线程阻塞
   为了解决对共享存储区的访问冲突，Java 引入了同步机制，现在让我们来考察多个线程对共享资源的访问，显然同步机制已经不够了，
   因为在任意时刻所要求的资源不一定已经准备好了被访问，反过来，同一时刻准备好了的资源也可能不止一个。
   为了解决这种情况下的访问控制问题，Java 引入了对阻塞机制的支持.
   阻塞指的是暂停一个线程的执行以等待某个条件发生（如某资源就绪），学过操作系统的同学对它一定已经很熟悉了。
   Java 提供了大量方法来支持阻塞，下面让我们逐一分析。
   (1)sleep() 方法：sleep() 允许 指定以毫秒为单位的一段时间作为参数，它使得线程在指定的时间内进入阻塞状态，不能得到CPU 时间，
                   指定的时间一过，线程重新进入可执行状态。 典型地，sleep() 被用在等待某个资源就绪的情形：
                   测试发现条件不满足后，让线程阻塞一段时间后重新测试，直到条件满足为止。
   (2)suspend() 和 resume() 方法：两个方法配套使用，suspend()使得线程进入阻塞状态，并且不会自动恢复，必须其对应的resume() 被调用，
                                 才能使得线程重新进入可执行状态。典型地，suspend() 和 resume() 被用在等待另一个线程产生的结果的情形：
                                 测试发现结果还没有产生后，让线程阻塞，另一个线程产生了结果后，调用 resume() 使其恢复。
   (3)yield() 方法：yield() 使得线程放弃当前分得的 CPU 时间，但是不使线程阻塞，即线程仍处于可执行状态，随时可能再次分得 CPU 时间。
                   调用 yield() 的效果等价于调度程序认为该线程已执行了足够的时间从而转到另一个线程.
   (4)wait() 和 notify() 方法：两个方法配套使用，wait() 使得线程进入阻塞状态，它有两种形式，一种允许 指定以毫秒为单位的一段时间作为参数，
                              另一种没有参数，前者当对应的 notify() 被调用或者超出指定时间时线程重新进入可执行状态，
                              后者则必须对应的 notify() 被调用.
             前面叙述的所有方法都隶属于 Thread 类，但是这一对却直接隶属于 Object 类，也就是说，所有对象都拥有这一对方法。
             初看起来这十分不可思议，但是实际上却是很自然的，因为这一对方法阻塞时要释放占用的锁，而锁是任何对象都具有的，
             调用任意对象的 wait() 方法导致线程阻塞，并且该对象上的锁被释放。而调用 任意对象的notify()方法
             则导致因调用该对象的 wait() 方法而阻塞的线程中随机选择的一个解除阻塞（但要等到获得锁后才真正可执行）。
             前面叙述的所有方法都可在任何位置调用，但是这一对方法却必须在 synchronized 方法或块中调用，理由也很简单，
             只有在synchronized 方法或块中当前线程才占有锁，才有锁可以释放。同样的道理，调用这一对方法的对象上的锁必须为当前线程所拥有，
             这样才有锁可以释放。因此，这一对方法调用必须放置在这样的 synchronized 方法或块中，该方法或块的上锁对象就是调用这一对方法的对象。
             若不满足这一条件，则程序虽然仍能编译，但在运行时会出现IllegalMonitorStateException 异常。
             wait() 和 notify() 方法的上述特性决定了它们经常和synchronized 方法或块一起使用，
             将它们和操作系统的进程间通信机制作一个比较就会发现它们的相似性：synchronized方法或块提供了类似于操作系统原语的功能，
             它们的执行不会受到多线程机制的干扰，而这一对方法则相当于 block 和wakeup 原语（这一对方法均声明为 synchronized）。
             它们的结合使得我们可以实现操作系统上一系列精妙的进程间通信的算法（如信号量算法），并用于解决各种复杂的线程间通信问题。

